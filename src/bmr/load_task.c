/*
 * Created by Geoff Crewe.
 *
 * Copyright 2011 MIT Haystack Observatory 
 *  
 * This file is part of mark6.
 *
 * mark6 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * mark6 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with mark6.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */

/*
 * $Id: load_task.c 984 2011-02-08 17:02:31Z gbc $
 *
 * Implementation of the LOAD task.
 */

#include <errno.h>
#include <fcntl.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bmr_files.h"
#include "bmr_util.h"
#include "grab_task.h"
#include "load_task.h"

/*
 * LOAD private data
 */
static LoadState    lss;
static LoadInfo     lis;

/*
 * a lookup of fd -> filed[] index for per-file diagnostics
static int	    fsize_max, fd2index[1024];
 */

/*
 * LOAD Public (read-only) Data
 */
void const **	    current_load_write_ptr = (void const **)&lss.mem_write;
int * const	    current_load_fd_ptr = &lss.load_fd;
Reader **           current_load_reader_ptr = &lss.load_reader;

/*
 * The SAVE task will have written to multiple files (if allowed)
 * and the order of the writes is not guaranteed.  Therefore on
 * the load, we'll want to funnel the packets through an inline sort.
 *
 * If there is only one file, then we read directly into mem_write.
 *
 * With multiple files, we can read directly into mem_write if the
 * SEND operation does the implicit sort.  (I.e. it must pick the
 * next packet to be sent among the packets available.)
 *
 * FIXME -- buck passed back to SEND module.
 */

/*
 * FIXME: consider why we might not want to read
 * lis.notr.* available for some reasons.
 */
static int must_not_read(void)
{
    return(lis.notr.ok++,0);
}

/*
 * This reads the packet + seqn from the file without any edits
 * and afterwards moves the pointer forward (no matter what).
 *
 * This assumes only a single file is in use.
 */
static ssize_t load_reader_raw(void)
{
    int	nr;

    lis.reading.called ++;
    if (must_not_read()) return(0);

    nr = read(lss.load_fd, lss.mem_write, lss.load_size);
    lss.next_seqn = *(int64_t*)lss.mem_write;
    if (errno != 0) { lis.reading.syserr ++; errno = 0; }
    /* update counters */
    if (nr == lss.load_size) {
	lis.reading.bytes += nr;
	lis.reading.pkts ++;
    } else {
	lis.reading.sizerr ++;
    }
    /* advance to the next packet */
    lss.mem_write += lss.mem_chunk;
    if (lss.mem_write - lss.mem_start >= lss.mem_size)
	lss.mem_write = lss.mem_start;
    *(int64_t*)lss.mem_write = BMR_SEQN_INVALID;
    return(nr);
}

/*
 * Same as load_reader_raw() but only the pkt is read;
 * the seqn number is generated by us.
 *
 * This assumes only a single file is in use.
 */
static ssize_t load_reader_pkt(void)
{
    int	nr;

    lis.reading.called ++;
    if (must_not_read()) return(0);

    *(int64_t*)lss.mem_write = lss.next_seqn++;
    nr = read(lss.load_fd, lss.mem_write + sizeof(int64_t), lss.load_size);
    if (errno != 0) { lis.reading.syserr ++; errno = 0; }
    /* update counters */
    if (nr == lss.load_size) {
	lis.reading.bytes += nr;
	lis.reading.pkts ++;
    } else {
	lis.reading.sizerr ++;
    }
    /* advance to the next packet */
    lss.mem_write += lss.mem_chunk;
    if (lss.mem_write - lss.mem_start >= lss.mem_size)
	lss.mem_write = lss.mem_start;
    *(int64_t*)lss.mem_write = BMR_SEQN_INVALID;
    return(nr);
}

/*
 * Like load_reader_pkt() but with internal seqn number
 */
static ssize_t load_reader_edv(void)
{
    int nr;

    lis.reading.called ++;
    if (must_not_read()) return(0);
    nr = read(lss.load_fd, lss.mem_write, lss.load_size);
    if (errno != 0) { lis.reading.syserr ++; errno = 0; }
    /* update counters */
    if (nr == lss.load_size) {
	lis.reading.bytes += nr;
	lis.reading.pkts ++;
    } else {
	lis.reading.sizerr ++;
    }
    /* advance to the next packet */
    lss.mem_write += lss.mem_chunk;
    if (lss.mem_write - lss.mem_start >= lss.mem_size)
	lss.mem_write = lss.mem_start;
    *(int64_t*)lss.mem_write = BMR_PKT_NOTVALID;
    return(nr);
}

/*
 * This is a no-op.
 */
static ssize_t load_idler(void)
{
    lis.idling.called ++;
    return(0);
}

/*
 * For the descriptive tasks, this is more useful than a pointer.
 */
char *load_reader_name(void *reader)
{
    if (reader == load_reader_raw) return("raw");
    if (reader == load_reader_pkt) return("pkt");
    if (reader == load_reader_edv) return("edv");
    if (reader == load_idler) return("idler");
    return("fault");
}

/*
 * Capture the exact times of entry/exit from reading mode.
 * On entry, capture the time in lis.reading_entry,
 * on exit, increase the total in lis.reading_time.
 */
static void load_read_timing(int entry)
{
    TimeSpec	exit_time;
    if (entry) {
	clock_gettime(CLOCK_REALTIME, &lis.reading_entry);
    } else if (lis.reading_entry.tv_sec > 0) {
	clock_gettime(CLOCK_REALTIME, &exit_time);
	time_increment(&lis.reading_time,
	    time_decrement(&exit_time, &lis.reading_entry));
	lis.reading_entry.tv_sec = 0;	/* accumulate once! */
    }
}

/*
 * Assign the handler based on the action.
 */
static void set_load_action(int action, LoadState *ls)
{
    switch (action) {
    case LOAD_ACT_IDLE:
	if (ls->verb>0 && action != ls->action)
	    fputs("Idle loader\n", stderr);
	ls->load_reader = load_idler;
	break;
    case LOAD_ACT_INIT:
	if (ls->verb>0) fputs("Init loader\n", stderr);
	ls->load_reader = load_idler;
	break;
    case LOAD_ACT_NONE:
	if (ls->verb>0) fputs("None loader\n", stderr);
	ls->load_reader = load_idler;
	load_read_timing(0);
	break;
    case LOAD_ACT_READ:
	switch (ls->file_fmt) {
	case BMR_FILE_RAW:
	    if (ls->verb>0) fputs("File loader raw\n", stderr);
	    ls->load_reader = load_reader_raw;
	    break;
	case BMR_FILE_PKT:
	    if (ls->mem_type == BMR_MEM_SEQN) {
		if (ls->verb>0) fputs("File loader pkt\n", stderr);
		ls->load_reader = load_reader_pkt;
	    } else {
		if (ls->verb>0) fputs("File loader edv\n", stderr);
		ls->load_reader = load_reader_edv;
	    }
	    break;
	/* FIXME: BMR_FILE_PSN, BMR_FILE_VDF, BMR_FILE_VDX */
	default:
	    if (ls->verb>0) fprintf(stderr,
		"Illegal file_fmt %d\n", ls->file_fmt);
	    action = LOAD_ACT_IDLE;
	}
	load_read_timing(1);
	break;
    default:
	if (ls->verb>0) fprintf(stderr,
	    "Illegal load action %d\n", action);
	action = LOAD_ACT_IDLE;
    }
    ls->action = action;
}

/*
 * Close any files that are open.
 * We also truncate the paths at the dir/file point.
 */
void load_files_yank(void)
{
    static int	again = 0;
    char	*slash;
    int		lf;
    if (lss.verb>0) fputs("Closing LOAD files.\n", stderr);
    if (again++) for (lf = 0; lf < lss.num_files; lf ++) {
	if (lss.filed[lf] >= 0) close(lss.filed[lf]);
	slash = lss.path[lf] ? strrchr(lss.path[lf], '/') : 0;
	if (slash) *slash = 0;
	lss.filed[lf] = -1;
    }
    lss.file_index ++;
    if (lss.mem_start) free(lss.mem_start - BMR_MALLOC_GUARD);
    set_load_action(LOAD_ACT_IDLE, &lss);
}

/*
 * Generate a file name from the path, scan and index
 * FIXME -- checks on filesystem capacity?
 */
static char *load_file_path(LoadState *ls, int lf)
{
    ssize_t	plen;
    char	fndx[20], *path = ls->path[lf];
    if (!path) {
	path = malloc(8);
	if (path) snprintf(path, 8, "./");
	else return(perror("malloc:load_file_path"),NULL);
    }
    plen = strlen(path) + strlen(ls->scan_label) + 40;
    path = realloc(path, plen);
    strcat(path, "/");
    strcat(path, ls->scan_label);
    snprintf(fndx, sizeof(fndx), "_%d.bmr", ls->file_index++);
    strcat(path, fndx);
    if (ls->verb>0) fprintf(stderr, "File %d is %s\n", lf, path);
    return(path);
}

/*
 * Set up the file infrastructure.
 * Returns nonzero if we cannot proceed.
 */
int load_files_prep(LoadState *ls)
{
    int	    sf;
    if (ls->verb>0) fputs("Opening LOAD files.\n", stderr);
    if (ls->file_index < lss.file_index) ls->file_index = lss.file_index;
    for (sf = 0; sf < ls->num_files; sf++) {
	ls->path[sf] = load_file_path(ls, sf);
	if (!ls->path[sf]) return(fprintf(stderr, "Error on file %d\n", sf));
	ls->filed[sf] = open(ls->path[sf], O_RDONLY, 0666);
	if (ls->filed[sf] < 0) {
	    perror("open");
	    fprintf(stderr, "Error on file %s (%d)\n", ls->path[sf], sf);
	    free(ls->path[sf]);
	    return(sf+1);
	}
    }
    return(0);
}

/*
 * Set up the timing....
 * Similar to grab_timing_prep().
 */
static int load_timing_prep(LoadState *ls)
{
    time_t  now = time(0) + 3;

    if (ls->load_secs < 1)
	return(fputs("min secs is 1\n", stderr));
    if (ls->load_period < 3)
	return(fputs("min period is 3\n", stderr));
    if (ls->load_period < ls->load_secs)
	return(fputs("period < secs\n", stderr));
    if (ls->load_start <= now)
	return(fputs("Start < NOW + 3s\n", stderr));
    if (ls->load_stop <= ls->load_start)
	return(fputs("Stop < Start\n", stderr));

    ls->load_idle   = ls->load_period - ls->load_secs;
    ls->load_cycles =
	(int)floor((0.5 + ls->load_stop - ls->load_start) / ls->load_period);

    return(0);
}

/*
 * Check the time and, as required, switch between the
 * reading and not reading states (if not IDLE).  The
 * rep counter decrements after the NONE state, and
 * we shift to the idle state when it hits zero.
 *
 * We care most about performance in the READ state
 * (which actually has to load packets).
 *
 * INIT -> NONE -> READ -> NONE ( -> IDLE finally )
 *
 * The active/passive logic resembles that of GRAB,
 * except there is no need for the NONE/PUNT distinction.
 *
 * Return 0 indicates we want to read packets,
 * Return 1 indicates the read file descriptors should be ignored.
 */
int check_load_state(void)
{
    time_t	now = time(0);
    switch (lss.action) {

    case LOAD_ACT_READ:
	if (now < lss.load_passive) return(0);
	lss.load_passive += lss.load_period;
	set_load_action(LOAD_ACT_NONE, &lss);
	return(1);

    case LOAD_ACT_NONE:
	if (now < lss.load_active) return(1);
	lss.load_active += lss.load_period;
	if (lss.load_reps-- > 0) {
	    set_load_action(LOAD_ACT_READ, &lss);
	    return(0);
	}
	/* fall through to IDLE */
    default:
    case LOAD_ACT_IDLE:
	set_load_action(LOAD_ACT_IDLE, &lss);
	break;

    case LOAD_ACT_INIT:
	lss.load_active = lss.load_start;
	lss.load_passive = lss.load_start + lss.load_secs;
	lss.load_reps = lss.load_cycles;
	set_load_action(LOAD_ACT_NONE, &lss);
	break;

    }
    return(1);
}

/*
 * Work out the number of bytes to be written each input packet
 */
static int load_chunk_prep(LoadState *ls)
{
    switch (ls->file_fmt) {
    case BMR_FILE_RAW:
	ls->mem_chunk = ls->load_size + sizeof(int64_t);
	break;
    /* FIXME: BMR_FILE_PSN, BMR_FILE_VDF, BMR_FILE_VDX */
    case BMR_FILE_PKT:
    case BMR_FILE_VDF:
    case BMR_FILE_VDE:
    case BMR_FILE_VDX:
	ls->mem_chunk = ls->load_size;
	break;
    default:
	return(fprintf(stderr, "Illegal file_fmt %d\n", ls->file_fmt));
    }
    return(0);
}

/*
 * Set up the loaded data buffer area.
 * This is similar to grab_buffer_prep(), however the relation
 * of chunk and load_size is controlled by the data format.
 *
 * The 2*BMR_MALLOC_GUARD isn't necessary here, but we do it
 * for similarity's sake.
 */
static int load_buffer_prep(LoadState *ls)
{
    if (load_chunk_prep(ls)) return(1);
    ls->mem_size = (2 + ls->load_secs) * ls->load_rate * ls->mem_chunk;
    ls->mem_start = malloc(ls->mem_size + 2*BMR_MALLOC_GUARD);
    if (!ls->mem_start)
	return(perror("load_buffer_prep"),
	       fprintf(stderr, "Attempted %lu bytes\n",
		(unsigned long)ls->mem_size));
    ls->mem_start += BMR_MALLOC_GUARD;
    ls->mem_write = ls->mem_start;
    if (ls->mem_type == BMR_MEM_SEQN) {
	*(int64_t *)ls->mem_start = BMR_SEQN_INVALID;
    } else {
	*(int64_t *)ls->mem_start = BMR_PKT_NOTVALID;
    }
    return(0);
}

/*
 * Nuking the LoadInfo structure is a good start.
 */
static int load_stats_prep(LoadState *ls)
{
    memset(&lis, 0, sizeof(lis));
    return(0);
}

/*
 * At present the only work here is to make sure
 * that the next_seqn counter is monotonic.
 */
static void update_load_state(LoadState *ls)
{
    int64_t	old_seqn;
    old_seqn = lss.next_seqn;
    lss = *ls;	    /* make it so, #1 */
    lss.next_seqn = old_seqn;
    check_load_state();
}

/*
 * Shut down any reading activity in progress and initialize a new activity.
 */
int set_load_state(LoadState *ls)
{
    load_files_yank();
    if (ls->verb>0) rlimit_env();

    if (load_stats_prep(ls))
	return(fputs("Failed to initialize load stats.\n", stderr));

    if (load_buffer_prep(ls))
	return(fputs("Failed to initialize load buffer.\n", stderr));

    if (load_timing_prep(ls))
	return(fputs("Failed to initialize load timing.\n", stderr));

    if (load_files_prep(ls)) {
	load_files_yank();
	return(fputs("Failed to initialize load files.\n", stderr));
    }

    update_load_state(ls);
    return(0);
}

/*
 * Methods to return safe copies of our internals.
 */
LoadInfo *get_load_info(void)
{
    static LoadInfo	mine;
    clock_gettime(CLOCK_REALTIME, &lis.load_time);
    lis.load_state = lss;
    mine = lis;
    return(&mine);
}
LoadState *get_load_state(void)
{
    static LoadState	mine;
    mine = lss;
    return(&mine);
}

/*
 * eof
 */
